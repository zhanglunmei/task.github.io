# JavaScript

## 基础方法

```javascript
prompt()  输入框
alert()  警示框
```



## 1、简单的数据类型

| 简单的数据类型 | 说明                                         | 默认值    |
| -------------- | -------------------------------------------- | --------- |
| Number         | 数字型，包含 整形和浮点型 如21、30.12        | 0         |
| Boolean        | 布尔值类型，如true，false，等价于1和0        | false     |
| String         | 字符串类型，如‘张三’，js里面，字符串都带引号 | “”        |
| Undefined      | var a'声明了a但是没有值，此时a=undefined     | undefined |
| Null           | var a=null;声明了变量a为空值                 | null      |

### 1.1、数字型  Number

​	八进制

​	`0~7 在程序的数字前面加0 表示八进制`

​	十六进制

​	`0~9 a~f  #fffff 数字面前加 0x 表示十六进制`

​	最大值

​	`Number.MAX_VALUE`

​	最小值

​	`Number.MIN_VALUE`

​	无穷大

​	`Number.MAX_VALUE*2`

#### 	isNaN()方法：

​	用来判断非数字  并返回bool值，如果是数字返回false，不是返回true

### 1.2、字符串型 String

​	字符串可以是引号中的任意文本，其语法为双引号 " " 和单引号 ' '

```javascript
var strMsg = 'aaaaa';
var strMsg2="猪蹄";
```

#### 1.2.1、字符串转义符

​	类似HTML里面的特殊字符。字符串中也有特殊字符，我们称之为转义符

​	转义符都是\开头的，常用的转义符及其说明如下

| 转义符 | 解释说明   |
| ------ | ---------- |
| \n     | 换行符     |
| \\     | 斜杠\      |
| \\'    | ‘ 单引号   |
| \ "    | " 双引号   |
| \t     | table 缩进 |
| \b     | 空格       |

#### 1.2.1、字符串长度 Lenght	

​	字符串的拼接 + 只要是字符串类型和其他类型拼接 结果都是字符串类型

### 1.3、布尔型 Boolean

布尔类型只有两个值，true和false，true表示对(真)，false表示错(假)

### 1.4、Undefined 和Null

声明一个变量如果为赋值，就是undefined未定义数据类型

一个声明变量给Null值，里面存的值为空

### 1.5、获取检测变量的数据类型

​	typeof()可用来获取检测变量的数据类型

### 1.6、数据类型的转换

#### 1.6.1、转换为字符串类型

| 方式              | 说明                         | 案例                         |
| ----------------- | ---------------------------- | ---------------------------- |
| toString()        | 转成字符串                   | var nun=1;   num.toString    |
| String() 强制转换 | 转成字符串                   | var nun=1;   String(num)；   |
| 加号字符串拼接    | 和字符串拼接的结果都是字符串 | var num=1; mun+'我是字符串'; |

```javascript
var num = 1;
//
var str = num.toString();
var str2 = String(num);
var str3 = num+'我是字符串';
```

#### 1.6.2、转换为数字型

| 方式                   | 说明                         | 案例                |
| ---------------------- | ---------------------------- | ------------------- |
| parseInt(string)函数   | 将String类型转换成整数数值型 | parseInt('78')      |
| parseFloat(string)函数 | 将String类型转换为浮点数值型 | parseFloat('78.21') |
| Number()强制转换函数   | 将String类型转换为数值型     | Number('21')        |
| js隐式转换(- * /)      | 利用算数运算隐式转换为数值型 | '12'-0              |

```javascript
var age = '18';
var age2 = '18.24';
parseInt(age);
parseFloat(age2);
Number(age);
age - 0 ;
```

#### 1.6.3、转换为布尔型

| 方式      | 说明                 | 案例            |
| --------- | -------------------- | --------------- |
| Boolean() | 其他类型转换成布尔型 | Bollean('true') |

**代表空，否定的值会被转换成false，如 ''、0、NaN、null、undefined **

**其他的值都会被转成true**

```javascript
console.log(Boolean(''));		//false
console.log(Boolean(0));		//false
console.log(Boolean(NaN));  	//false
console.log(Boolean(null)); 	//false
console.log(Boolean(undefined));//false
console.log(Boolean('小白'));	  //true
console.log(Boolean(12));	   //true
```

## 2、运算符

### 2.1、算数运算符

概念：算术运算符使用的符合，用于执行两个变量或值的算术运算

| 运算符 | 描述         | 实例                 |
| ------ | ------------ | -------------------- |
| +      | 加           | 10+20=30             |
| -      | 减           | 20-10=10             |
| *      | 乘           | 10*1=10              |
| /      | 除           | 10/20=0.5            |
| %      | 取余数(取模) | 返回除法的余数 9%2=1 |

### 2.2、表达式和返回值

​	表达式：是由数字、运算符、变量等能以求得数值的有意义排列方法所得的组合

​	简单理解：是由数字、运算符、变量组成的语句

​	表达式都会有一个结果，我们称之为返回值

### 2.3、递增和递减运算符

​	如果需要给数字变量添加或减去1.可以使用递增(++)和递减(--)运算符来完成

​	在JavaScript中，递增(++)和递减(--)既可以放在变量的前面也可以放在变量的后面。放在变量前面时，我们可以称之为前置递增(递减)运算符，放在后面时，我们可以称之为后置递增(递减)运算符

#### 	2.3.1前置递增运算符

​	++num前置递增。就是自加1，类似于num=num+1,但是++num写起来更简单

#### 	2.3.2后置递增运算符

​	num++后置递增。就是自加1，类似于num=num+1,但是num++写起来更简单  

​	先返回原值 在自增

#### 	2.3.3前置递增和后置递增小结

​	前置递增和后置递增可以简化代码的编写，让变量的值加一，比以前的写法更简单

​	单独使用时，运行结果相同

​	与其他代码关联时，执行结果会不同

​	后置：先算原值运算，后自加

​	前置：先自加，后运算

​	开发时，大多使用后置递增/递减，并且代码独占一行，例如:num++;或者num--;

### 2.4、比较运算符

#### 	2.4.1、比较运算符的概念

​	概念：比较运算符(关系运算符)是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值(true/false)作为比较运算的结果。

| 运算符名称 | 说明             | 案例        | 结果  |
| ---------- | ---------------- | ----------- | ----- |
| <          | 小于             | 1 < 2       | true  |
| >          | 大于             | 1 > 2       | false |
| >=         | 大于等于         | 2 >= 2      | true  |
| <=         | 小于等于         | 3 <= 2      | false |
| ==         | 等于(会转换类型) | 37 == 37    | true  |
| !=         | 不等于           | 37 != 37    | false |
| === !===   | 全等 和 全不等   | 37 === '37' | false |

### 2.5、逻辑运算符

​	概念：逻辑运算符是用来进行布尔值运算的运算符，其他返回的也是布尔值，经常用于多个条件的判断

| 逻辑运算符 | 说明               | 案例           |
| ---------- | ------------------ | -------------- |
| &&         | 逻辑与 简称 与 and | true && false  |
| \|\|       | 逻辑或 简称 或 or  | true \|\| true |
| ！         | 逻辑非 简称 非 not | ! true         |

### 2.6、赋值运算符

​	概念：用来把数据赋值给变量的运算符

| 赋值运算符 | 说明                 | 案例                       |
| ---------- | -------------------- | -------------------------- |
| =          | 直接赋值             | var usrName = '值'         |
| +=，-=     | 加 减 一个数后在赋值 | var age = 15; age+=5; //20 |
| *=，/=，%= | 乘 除 取模 后在赋值  | var age=2; age*=5;  //10   |

### 2.7、运算符的优先级

| 优先级 | 运算符     | 顺序            |
| ------ | ---------- | --------------- |
| 1      | 小括号     | ()              |
| 2      | 一元运算符 | ++ -- !         |
| 3      | 算数运算符 | 先 * / % 后 + - |
| 4      | 关系运算符 | > >= < <=       |
| 5      | 相等运算符 | == != === !==   |
| 6      | 逻辑运算符 | 先 && 后 \|\|   |
| 7      | 赋值运算符 | =               |
| 8      | 逗号运算符 | ，              |

## 3、流程控制

​	流程控制主要有三种结构，分别是顺序结构，分支结构和循环结构，这三种结构代表三种代码执行顺序

### 	3.1、顺序结构

​	顺序结构是程序中最简单，最基本的流程控制，他没有特定的语法，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行

### 	3.2、分支结构

​	由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码(执行代码多选一的过程)，从而得到不同的结果

#### 	3.2.1、if分支语句

```javascript
//语法结构
if(条件表达式){
    执行语句
}
//执行思路，如果括号里面的条件表达式为真 则执行大括号里面的 执行语句
//如果条件表达式为假 则执行if后面的代码
```

#### 	3.2.2 if else 双分支结构

```javascript
//语法结构
if(条件表达式){
    执行语句1
}else{
    执行语句2
}
//如果条件表达式为真，执行 执行语句1 ，如果为假，执行 执行语句2
```

#### 	3.2.3 if else if 多分支语句

```javascript
//多分支语句 就是利用多个条件来选择不同的语句执行 得到不同的结果 多选一
//语法结构
if(条件表达式){
    执行语句1
}else if(条件表达式){
    执行语句2
}else if(条件表达式){
    执行语句3
}else{
    执行语句4
}
//执行思路
//如果条件表达式1 满足就执行 语句1 执行完毕后退出整个分支语句
//如果条件表达式1 不满足 则判断条件表达式2 满足的话，执行语句2 以此类推
//如果上面的所有条件表达式都不满足则执行else里面的语句
```

#### 	3.2.4、三元 表达式

```javascript
//语法结构
条件表达式?表达式1:表达式2
//执行思路
//如果条件表达式为真返回表达式1的值
//如果条件表达式为假返回表达式2的值
```

#### 	3.2.5、switch语句

```javascript
switch(表达式){
    case value1:
        执行语句2
        break;
	case value1:
        执行语句2
        break;
	...
    default:
    	执行最后的语句
        break;
}
//执行思路
//利用我们的表达式的值 和 case 后面的选项值相匹配 如果匹配上，就执行case里面的语句
//如果所有的case的值都没匹配上，就执行default里面的语句
```

#### 	3.2.6、switch 和 if else if 语句的区别

​	一般情况下，他们两个语句可以相互替换

​	switch...case 语句通常处理case为比较确定值的情况，而if~else...语句更加灵活，常用于范围判断

​	switch语句进行条件判断后直接执行到程序条件语句，效率更高。if~else 语句有几种条件，就得判断多少次

​	当分支比较少时，if~else语句的执行效率比switch更高

​	当分支比较多时，switch语句的执行效率更高，而且结构更加清晰

### 	3.3、循环结构

#### 	3.3.1、循环的目的

​	在实际问题中，有许多具有规律性的重复操作，因此在程序中要完成这类操作就需要重复执行某些语句

#### 	3.3.2、js中的循环

​	在js中，主要有三种类型的循环语句：

​	for循环

​	while循环

​	do...while循环

#### 	3.3.3、for循环

​	在程序中，一组重复执行的语句被称之为循环体，能否继续重复执行，取决于循环终止的条件。由循环体及循环的终止条件组成的语句，称之为循环语句

```javascript
//语法结构
for(初始变量；条件表达式；操作表达式){
    //循环体
}
//初始变量 就是var声明一个普通变量，通常作为计数器使用
//条件表达式 就是来决定每一次循环是否继续执行 就是终止的条件
//操作表达式 是每次循环最后执行的代码 经常用于我们的计数器变量进行更新(递增或递减)
//完整语句
for(var i=0;i<100;i++){
    console.log('你好');
}
//首先执行计数器里面的变量 var i=0,但这句话在for里面只执行一次 index
//去i<100来判断是否满足条件，如果满足条件 就去执行循环体 不满足退出循环
//最后去执行i++ i++是单独写的代码 递增 第一轮结束
//接着去执行 i<100 如果满足条件 就去执行循环体 不满足退出循环 以此类推
```

#### 	3.3.4、双重for循环

```javascript
//语法结构
for(外层的初始变量；外层的条件表达式；外层的操作表达式){
    for(里程的初始变量；里层的条件表达式；里层的操作表达式){
        //执行语句
    }
}
//我们可以吧里面的循环看作是外层循环的语句
//外层循环循环一次，里面的循环执行全部
```

#### 	3.3.5、for循环小结

​	for循环可以重复执行某些相同的代码

​	for循环可以重复执行些许不同的代码，因为我们有计数器

​	for循环可以重复执行某些操作，比如算术运算符加法操作

​	随着需求增加，双重for循环可以做更多、更好看的效果

​	双重for循环，外层执行一次，内层for循环全部执行

​	for循环是循环条件和数字直接相关的循环

#### 	3.3.6、while循环

```javascript
//语法结构
while(条件表达式){
    //循环体代码
}
//执行思路
//当条件表达式结果为true 则执行循环体 否则 退出循环体
//里面应该也有计数器 初始化变量
//里面应该也有操作表达式， 完成计数器的更新 防止死循环	
```

#### 	3.3.7、do..while循环

```javascript
//do...while 语句其实是while语句的一个变体。该循环会先执行一次代码块，然后对条件表达式进行判断，如果条件为真，就会重复执行循环体，否则退出循环体
//语法结构
do{
    //循环体
}while(条件表达式){
    //循环体
}
```

#### 3.3.8、循环小结

​	JS中循环有for while do..while

​	三个循环很多情况下都可以相互替代使用

​	如果是用来计数，更数字相关的，三者使用基本相同

​	while和do...while可以做更复杂的判断条件，比for循环灵活一些

​	while和do...while执行顺序不一样，while先判断在执行，do...while先执行一次，在判断执行

​	while和do...while执行次数不一样，do...while至少会执行一次，而while可能一次也不执行

#### 3.3.9、continue break关键字

​	continue关键字

​		用于跳出本次循环，继续下一个循环

​	break关键字

​		用于跳出整个循环

## 4、数组

​	 数组是指一组数据的集合，其中每个数据被称为元素，在数组中可以存放任意类型的元素

### 	4.1、创建数组

​	利用new 创建数组

```javascript
var arr = new Array();		//创建了一个空数组
```

​	利用数组字面量创建数组

```javascript
var arr = [];		//创建了一个空数组
```

### 	4.2、访问数组元素

#### 		4.2.1、数组的索引

​		索引(下标):用来访问数组元素的序号(数组下标从开始)

### 	4.3、便利数组

​	遍历：就是吧数组中的每一元素都访问一次

#### 	4.3.1、数组长度

​	数组名.length

​	数组长度，是数组元素的个数

### 4.4、数组中新增元素

#### 	4.4.1、可以通过修改Length长度来新增数组元素

​	可以通过修改length长度来实现数组扩容的目的

​	length属性是可读写的

## 5、函数

​	函数就是封装了一段可以被重复执行的代码块 目的：就是让代码重复使用

### 	5.1、函数的使用

​		声明函数于调用函数

```javascript
//语法结构
function 函数名(){
    //函数体
}
//声明函数
function sayHi(){
    console.log('hi~~')
}
//function 声明函数的关键字 全部小写
//函数不会自动执行

//调用函数
sayHai();
```

### 	5.2、函数的参数

#### 	5.2.1、形参和实参

```javascript
function 函数名(参数1，参数2){//在声明函数的小括号里面的是 形参 （形式上的参数）
    //函数体
}

函数名(实参1，实参2)//在函数调用的小括号中里面的是 实参（实际参数）
//形参是接受实参的，类似于一个变量
```

#### 	5.2.2、函数的形参和实参的匹配问题

​	如果实参的个数和形参一致 则正常运行

​	如果实参的个数多于形参的个数 会取到形参的个数

​	如果实参的个数少于形参的个数 多余的形参定义为undefined

#### 	5.2.3、小结

​	函数可以带参数也可以不带参数

​	声明函数的时候，函数名括号里面的是形参，形参的默认值为undefined

​	调用函数的时候 函数名括号里面的是实参

​	多个参数中间用逗号分隔

​	形参的个数可以和实参个数不匹配，但是结构不可预估，要尽量匹配

#### 	5.2.3、函数的返回值return

​	函数将结果返回给调用者，此时通过使用return语句实现

```javascript
function 函数名(形参){
    //函数体
    return 要返回的结果
}
//如果有return就返回return后面的值
//没有return就返回undefined
```

#### 	5.2.4arguments使用

​	当不确定有多少参数传递的时候，可以用arguments来获取。在JavaScript中，arguments实际上他是当前函数的一个内置对象。所有的函数都内置了一个arguments对象，arguments对象中存储了传递的所有的实参

#### 	5.2.5、函数的声明方式

```javascript
//1.通过函数关键字定义函数
function fn(){
    
}
//2.函数表达式
var 变量名 = function(){
    
}
```

## 6、作用域

### 	6.1、JavaScript作用域

​	概述：通常来说，一段程序代码中所用到的名字并不是总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突

​	全局作用域：整个scripts标签或者整个js文件

​	局部作用域：在函数内部的就是局部作用域 这个代码的名字只在函数内部起作用

### 	6.2、变量作用域

​	在JavaScript中，根据作用域的不同，变量可以分为两种：

​	全局变量：在整个js文件或者scripts标签中

​			如果在函数内部 没有声明直接赋值的变量也属于全局变量

​	局部变量 ：在局部作用域下的变量 后者在函数内部的变量就是局部变量

​	从执行效率来看全局变量和局部变量

​		全局变量只有在关闭浏览器的时候才会销毁，比较占用内存资源

​		局部变量 当程序执行完毕就会销毁，比较节省资源

### 	6.3、作用域链

​	只要是代码，就至少有一个作用域

​	写在函数内部的局部作用域

​	如果函数中还有函数，那么在作用域中就又诞生了一个作用域

​	根据在内部函数可以访问外部函数变量的机制，用链式查找决定哪些数据能被内部函数访问，就称作作用链

## 7、预解析

​	JavaScript代码是由浏览器中的JavaScript解析器来执行的。JavaScript解析器在运行JavaScript代码的时候分两步：预解析和代码执行

​	预解析：js引擎会话js里面所有的var function 提升到当前作用域的前面

​	代码执行：按照代码书写的顺序从上往下执行

​	 预解析分为 变量预解析(变量提升)和函数预解析(函数提升)

​		变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作

​		函数提升 就是把所有的函数声明提升到当前作用域的最前面 不调用函数

## 8、对象

​	在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事务都是对象	，例如字符串、数值、数组、函数等

​	对象是由属性和方法组成的

​		属性：事务的特征，在对象中用属性来表示

​		方法：事务的行为，在对象中用方法来表示

### 	8.1、为什么需要对象

​	保存一个值时，可以使用变量，保存多个值时，可以使用数组，如果要保存一个人的完整信息，就可以使用JS中的对象，因为表达结构更清晰，更强大

### 	8.2、创建对象的三种方式

​	**利用字面量创建对象**

```javascript
var obj={
    uname='张三',
    age : 18,
    sex : '男',
    sayHi : function(){
        console.log('hi~')
    }
}
//里面的属性或者方法我们采取键值对的形式 键 属性名：值 属性值
//多个属性或方法之间用逗号隔开
//方法冒号后面跟的时一个匿名函数
//使用对象
//调用对象的属性 我们采取 对象名。属性名
obj.uname;
//调用属性还有一种方法 对象名['属性名'] 
obj['uname']
//调用对象的方法 对象名.方法名() 必须带小括号
obj.sayHi();
```

​	**利用new Object创建对象**

```javascript
var obj = new Object();	//创建了一个空对象
obj.uname = '张三';
obj.age = 18;
obj.sex='男';
obj.sayHi=function(){
    console.log('hi~')
}
//利用等号赋值的方法，给对象添加属性和方法
//每个属性和方法之间用分号结束
```

​	**利用构造函数创建对象**

​		因为我们一次创建一个对象，里面的很多属性和方法是大量相同的 我们只能复制

​		因此我们可以利用函数的方法 重复这些相同的代码 我们就把这个函数称为 构造函数

​		构造函数 就是把对象里面一些相同的属性和方法抽象出来封装到函数里面 

```javascript
//语法格式
function 构造函数名(){
    this.属性=值;
    this.方法=function(){}
}
//使用
new 构造函数名()

```

### 	8.2、遍历对象

```javascript
//语法结构
for(var k in obj){
    
}
```

##  9、内置对象

### 	9.1、Math对象

​	math 数学对象 不是一个构造函数，所有不需要new 来调用 而是直接使用里面的属性和方法即可

​	math对象不是构造函数，它具有数学和函数的属性和方法。跟数学相关的运算（求绝对值，取整，最大值等）可以使用math中的成员

```javascript
Math.PI  				//圆周率
Math.floor()			//向下取整
Math.ceil()				//向上取整
Math.round()			//四舍五入 就近取整
Math.abs()				//绝对值
Math.Max()/Math.Min()	//最大值或最小值
Math.random				//随机数
```

### 	9.2、日期对象

​	Date()日期对象 是一个构造函数 必须使用new 来调用创建我们的日期对象

```javascript
//使用Date
var date = new Date();
//如果没有参数 返回当前系统的日期时间
//参数常用的写法 数字型 2019，10，01 或者是字符型'2019-10-01 8:8:8'
```

​	**日期格式化**

​	需要获取日期指定的部分，需要手动获取

| 方法名        | 说明         | 代码              |
| ------------- | ------------ | ----------------- |
| getFullYear() | 获取年       | dObj.getFullYear  |
| getMonth()    | 获取月(0-11) | dObj.getMonth()+1 |
| getDate()     | 获取天       | dObj.getDate()    |
| getDay()      | 获取星期     | dObj.getDay()+1   |
| getHours()    | 获取当前小时 | dObj.getDay()     |
| getMinutes()  | 获取当前分钟 | dObj.getMinutes() |
| getSeconds()  | 获取当前秒   | dObj.getSeconds() |

​	Date总的毫秒数 不是当前时间的毫秒数 而是距离1970年1月1号过了多少毫秒

```javascript
//通过 valueOf()  getTime()
var date = new Date();
data.valueOf();
data.getTime();
//简单写法
var date = +new Date();
//新增写法
date.now();
```

​	**把总毫秒数转换为天，时，分，秒**

​	转换公式如下：

```javascript
d = parseInt(总秒数/60/60/24) //计算天数
h = parseInt(总秒数/60/60%24) //计算小时
m = parseInt(总秒数/60%60)	   //计算分钟
s = parseInt(总秒数%60)	   //计算秒
```

### 	9.3、数组对象

​	**检测是否为数组方法**

```JavaScript
//1.instanceof 运算符 它可以用来检测是否为数组
arr instanceof Array();
//2 数组.isArray(参数)
Array.isArray();
```

​	**添加删除数组元素**

```javascript
//1.push()在数组末尾 添加一个或多个数组元素
arr.push(4,'pink');
//2.unshift在数组前面 添加一个或多个数组元素
arr.unshift('aaa',4,8);
//3.pop()它可以删除数组的最后一个元素 一次只能删除一个
arr.pop()
//4.shift它可以删除数组的第一个元素 一次只能删除一个
arr.shift()
```

 	**数组排序**

| 方法名    | 说明                         | 是否修改原数组                    |
| --------- | ---------------------------- | --------------------------------- |
| reverse() | 颠倒数组中元素的顺序，无参数 | 该方法会改变原来的数组 返回新数组 |
| sort()    | 对数组中的元素进行排序       | 该方法会改变原来的数组 返回新数组 |

```javascript
sort(函数(a,b){
	return a-b;	//升序
     return b-a;//降序
})
```

​	**数组索引**

| 方法名        | 说明                           | 返回值                       |
| ------------- | ------------------------------ | ---------------------------- |
| indexOf       | 数组中查找给定元素的第一个索引 | 存在返回索引号，不存在返回-1 |
| lastIndexOf() | 在数组中的最后一个索引         | 存在返回索引号，不存在返回-1 |

​	**数组去重**

​	遍历旧数组，拿着旧数组的元素去查询新数组，如果该元素没有在新数组出现过，那就添加，否则就不添加

​	利用新数组.indexOf(元素) 返回结果为-1就说明 新数组里没有该元素

​	**数组转换成字符串**

| 方法名         | 说明                                       | 返回值         |
| -------------- | ------------------------------------------ | -------------- |
| toString()     | 把数组转换成字符串，逗号分隔每一项         | 返回一个字符串 |
| join('分隔符') | 方法用于把数组中的所有元素转换为一个字符串 | 返回一个字符串 |

​	**其他方法**

| 方法名   | 说明                                     | 返回值                          |
| -------- | ---------------------------------------- | ------------------------------- |
| concat() | 连接两个或多个数组 不影响原数组          | 返回一个新的数组                |
| slice()  | 数组截取slice(begin,end)                 | 返回被截取的新数组              |
| splice() | 数组删除splice(第几个开始，要删除的个数) | 返回被删除的新数组 会影响原数组 |

### 9.4、字符串对象

​	**基本包装类型**

​	为了方便操作基本数据类型 JavaScript还提供了三个特殊的引用类型：String Number和Bollean

​	基本包装类型就是把简单数据类型包装成复杂数据类型，这样基本数据类型就有了属性和方法

​	**字符串的不可变**

​	指定是里面的值不可变，虽然看上去可以改变内容，但其实是地址改变了，内存中开辟了一个新空间

​	**根据字符返回位置**

​	字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串

| 方法名                              | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| indexOf('要查找的字符'，开始的位置) | 返回指定内容在字符串中的位置，如果找不到就返回-1，开始的位置是索引号 |
| lastindexOf()                       | 从后往前查找 只找第一个匹配的                                |

​	**根据位置返回字符**

| 方法名          | 说明                                 | 使用            |
| --------------- | ------------------------------------ | --------------- |
| charAt(index)   | 返回指定位置的字符(index索引号)      | str.charAt(0)   |
| charCode(index) | 获取指定位置处的ASCII码(index索引号) | str.charCode(0) |
| str[index]      | 获取指定的位置                       | str[index]      |

​	**字符串操作方法**

| 方法名                                  | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| concat(str1,str2,str3..)                | concat()方法用于连接两个或多个字符串，拼接字符串，等效于+    |
| substr(start,length)                    | 从start位置开始，length取得个数                              |
| slice(start,end)                        | 从start位置开始，截取到end位置，不包含end                    |
| substring(start,end)                    | 从start位置开始，截取到end位置，不包含end 和slice基本相同 不接受负值 |
| replace('被替换的字符'，’替换为的字符‘) | 替换字符串中的字符                                           |
| split('分隔符')                         | 将字符串转换为数组                                           |

## 10、简单类型和复杂类型

​	简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型

​		值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型

​		string number boolean undefined null

​		引用类型：复杂数据类型，在存储变量中存储的仅仅是地址(引用)，因此叫做引用数据类型

​		通过new 关键字创建的对象(系统对象  自定义对象) 如Object Array Date等

### 	10.1、堆和栈

​	**堆栈空间分配区别**

​	1、栈(操作系统)：由操作系统自动分配释放存放的函数的参数值、局部变量的值等。其操作方式类似于结构中的栈：简单数据类型存放到栈里面

​	2、堆(操作系统)：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面

### 	10.2、简单类型传参

​	函数的形参也可以看成一个变量，当我们把一个值类型变量作为参数传递给函数的形参时，其实是把变量在栈空间里面的值复制了一份给形参，那么在方法内部做任何的修改，都不会影响到外部的变量

### 	10.3、复杂类型传参

​	函数的形参也可以看成一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间中保存的堆地址复制给了形参，形参和实参其实保存的是一个堆地址，所以操作的是同一个对象

## 11、DOM简介

### 	11..1、什么是DOM

​		文档对象模型(Document Object Model,简称DOM),是W3C组织推荐的处理可拓展标记语言(HTML或XML)的标准编程接口

### 	11.2、DOM树

![DOM树](E:\图片\笔记\DOM树.png)

​	文档：一个页面就是一个文档，DOM中使用doument表示

​	元素：页内所有标签都是元素，DOM中使用element表示

​	节点：网页中所有的内容都是节点(标签、属性、文本、注释等)，DOM中使用node表示 

## 12、获取元素

### 	12.1、如何获取页面元素

​	DOM在我们的实际开发中主要用来操作元素，

​	获取页面的元素可以使用以下几种方式：

```javascript
//根据ID获取
element.document.getElementById('ID名')
//根据标签名获取
element.document.getElementByTagName('标签名')	//返回的是一个伪数组
//通过HTML5新增方法获取
document.getElementClassName('类名')
document.querySelector('选择器') 
document.querySelectorAll('选择器') 
//特殊元素获取
//获取body元素
document.body;
//获取html元素
document.documetElement;
```

## 13、事件基础

### 	13.1、事件概述

​	JavaScript使我们有能力创建动态页面，而事件是可以被JavaScript侦测到的行为

​	简单理解：触发--响应机制

### 	13.2、执行事件步骤

​	1、获取事件源

​	2、注册事件

​	3、添加事件处理程序

### 	13.3常见的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获取鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedowm | 鼠标按下触发     |

## 14、操作元素

​	JavaScript的DOM操作可以改变网页的内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。

### 	14.1、改变元素内容

```javascript
//从起始位置到终止位置的内容，但他去除html标签，同时空格和换行会也去掉
element.innerText

//起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行
element.innerHTML
```

### 	14.2、修改元素的属性

```javascript
1.innnerText/innerHTML 改变元素内容
2.src herf
3.id alt title value
```

### 	14.3、修改表单属性

```javascript
//利用DOM可以操作如下表单元素的属性
type value check selected disabled
```

### 	14.4、修改属性操作

```javascript
element.style			//行内样式
element.className		//类名样式操作
element.classList		//类名样式操作
classList.add('类名')			//添加类名
classList.remove('类名')		//删除类名
classList.toggle('类名')		//如果类名存在那么就删除，如果不存在就添加
```

### 	14.5、自定义属性操作

```javascript
element.属性  //获取属性
element.getAttribute('属性') //获取属性
//区别
//element.属性  获取内置属性值(元素本身自带的属性)
//element.getAttribute('属性')  主要用于获取自定义的属性 （标准）

//设置属性值
element.属性='值'	//设置内置属性值
element.setAttribute('属性'，'值')	//设置属性值
//区别
//element.属性='值'  设置内置属性值(元素本身自带的属性)
//element.setAttribute('属性'，'值')  主要用于设置自定义的属性 （标准）

//移除属性值
removeAttribute('属性')
```

## 15、节点操作

### 	15.1、节点概述

​	一般地，节点至少拥有nodeType(节点类型)  nodeName(节点名称) nodeValue(节点值)这三个基本属性。

​	元素节点nodeType为1

​	属性节点nodeType为2

​	文本节点nodeType为3

​	在实际开发中，主要操作元素节点

### 	15.2、节点层级

​	利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系

![image-20220702164254850](E:\图片\笔记\节点层级.png)

| 属性                   | 说明               |
| ---------------------- | ------------------ |
| parentNode             | 父节点             |
| childNodes             | 子节点             |
| children               | 子元素节点         |
| firstChild             | 第一个子节点       |
| firstElementChild      | 第一个子元素节点   |
| lastChild              | 最后一个节点       |
| lsatElementChild       | 最后一个元素节点   |
| nextSibling            | 下一个兄弟节点     |
| nextElementSibling     | 下一个元素兄弟节点 |
| previousSibling        | 上一个兄弟节点     |
| previousElementSibling | 下一个元素兄弟节点 |

### 	15.3、创建节点

```javascript
doument.createElement('tagName');
//doument.createElement()方法创建由tagName指定的HTML元素，因为这些元素原先不存在，是根据我们的需求动态创建的，也称之为动态创建元素
```

### 15.4、添加节点

```javascript
element.appendChild(child)
//element.appendChild()方法将一个节点添加到指定的父节点的末尾 
element.insertBefore(child,指定元素)
//element.insertBefore()方法将一个节点添加到指定父节点的前面
```

### 15.5、删除节点

```javascript
element.removeChild(child)
//element.removeChild()方法从DOM中删除一个子节点，返回删除的节点
```

### 15.6、复制节点

```javascript
element.cloneNode()
//element.cloneNode()方法返回调用该方法的节点的一个副本，也成为复制节点或拷贝节点
//如果括号中的参数为空或者false，则是浅拷贝，即只克隆节点本身，不克隆里面的子节点
//如果括号中的参数为true，就是深拷贝，即拷贝自身
```

### 15.7、三种动态创建元素的区别

```javascript
document.write()
document.innerHTML()
document.createElement()
/*
*区别
*1.document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则会导致页面全部重绘
*2.innerHTML是将内容写入某个DOM节点，不会导致页面重置
*3.innerHTML创建多个元素效率更高(采取数组拼接形式)，结构稍微复杂
*4.createElement创建多个元素效率稍低，但是结构更加清晰
*/
```

## 16、DOM重点核心

​	文档对象模型(Document Object Model 简称DOM，简称DOM)，是W3C组织推荐的处理可扩展标记语言(HTML或XML)的标准编程接口

​	W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容，样式和结构

​	1、对于JavaScript，为了能够使JS操作HTML，JS就有了一套自己的dom编程接口

​	2、对于HTML，dom使得html形成一颗dom树，包含文档、元素、节点

## 17、注册事件

### 	17.1、注册事件概述

​	给元素添加事件，称为注册事件或者绑定事件

​	注册事件有两种方式：传统注册和监听注册方式

### 	17.2、传统注册方式

```javascript
/*
*利用on开头的事件  例如：onclick
*<button onclick="alert('hi~')">点击触发</button>
*btn.onclick = function(){}
*特点：事件注册的唯一性
*同一个元素同一个事件只能设置一个处理函数，最后注册的函数会覆盖前面注册的处理函数
*/
```

### 	17.3、方法监听注册方式

```javascript
/*
*w3c标准 推荐方式
*addEventListener()它是一个方法
*IE9之前的IE不支持此方法，可以使用addEvent()代替
*特点：同意一个元素同一个事件可以注册多个监听器
*按注册顺序依次执行
*/
element.addEventListener(type,listener,[useCapture])
//element.addEventListener()方法将指定的监听器注册到element上，当该对象触发指定的事件时，就会执行事件处理函数
/*
*该方法接收三个参数
*type：事件处理类型，比如click，mouseover,注意不带on
*listener:事件处理函数，事件发生时，会调用该监听函数
*useCapture:可选参数，是一个布尔值，默认时false
*/
```

### 	17.4、attachEvent事件监听方式

```javascript
element.attachEvent(eventNameWithOn,callback)
//element.attachEvent()方法将指定的监听器注册到element上，当该对象触发指定的事件时，指定的回调函数就会执行
/*该方法接收两个参数：
*eventNameWithOn：事件类型字符串，比如onclick ，onmouseover，要带on
*callback：事件处理函数，当目标触发事件时回调函数被调用
*/
```

## 18、删除事件

### 	18.1、删除传统事件的方式

```javascript
element.onclick = null;
```

​	18.2、方法监听事件注册方式

```javascript
element.removeEventListener(type,listener,[useCapturre])
//
element.datechEvent(eventNameWithOn,callback)
```

## 19、DOM事件流

​	事件流描述的是从页面中接收事件的顺序

​	事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流

​	DOM事件流分为三个阶段

​	  **捕获阶段**

​	  **当前目标阶段**

​	  **冒泡阶段**

​	事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程

​	事件捕获：网景最早提出，由DOM最顶层节点开始，逐级向下传播到最具体的元素的接收过程

​	**注意**

​	js代码中只能执行捕获或者冒泡其中的一个阶段

​	onclick和attchEvent只能到得冒泡阶段

​	addEvenetListener(tyep,listener,[useCapture])第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false(不行默认就是false)，表示在事件冒泡阶段调用事件处理程序

​	在实际开发中，很少使用事件捕获，更多的是事件冒泡

​	有些事件是没有冒泡的，比如onblur、onfocus、onmouseenter、onmouseleave

## 20、事件对象

```javascript
element.addEventListener('click',function(e){})
//e就是一个事件对象 写到侦听函数的小括号里面当作新参看
//事件对象只有有了对象才会存在，它是系统自动创建，不需要传递参数
//事件对象 是 事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标，，如果是键盘事件里面就包含的键盘事件的集合 比如判断用户按下的键
//事件对象我们可以自己命名 比如 event evt e
//事件对象也有兼容性的问题ie678通过window.event兼容性的写法获取 e=e||window.event
//简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个就是事件对象event，他有很多的属性和方法
```

## 21、事件对象常见的属性和方法

| 事件对象的属性和方法 | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| e.target             | 返回触发事件对象           标准                              |
| e.srcElement         | 返回触发事件对象           非标准                            |
| e.type               | 返回事件类型         比如click mouseover  不带on             |
| e.cancelBubble       | 该属性阻止冒泡     非标准                                    |
| e.returnValue        | 该属性 阻止默认事件(默认行为)  非标准  ie678使用比如不让连接跳转 |
| e.preeventDefault()  | 该方法 阻止默认事件(默认行为)  标准   比如不让连接跳转       |
| e.stopPropagation()  | 阻止冒泡    标准                                             |

## 22、事件委托(代理、委派)

事件冒泡本身的特性，会带来坏处，也会带来的好处，需要我们灵活掌握

​	**事件委托**

​	事件委托也称为事件代理，在JQuery里面称为事件委派

​	**事件委托的原理**

​	不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原来影响每个子节点

​	**事件委托的作用**

​	只操作了一次DOM ，提高了程序的性能

## 23、常用的事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmoueout   | 鼠标离开触发     |
| onmousemove | 鼠标移动触发     |
| onmousedown | 鼠标按下触发     |
| onmouseup   | 鼠标弹起触发     |
| contextmenu | 禁止鼠标右键菜单 |
| selectstart | 禁止选中文字     |

### 	23.1、鼠标事件对象

​	event对象代表事件的状态，跟事件相关的一系列信息的集合，现阶段我们主要用于鼠标事件对象MouseEvent和键盘事件对象keyboardEvent

| 鼠标事件对象 | 说明                                    |
| ------------ | --------------------------------------- |
| e.clienX     | 返回鼠标相对于浏览器窗口可视区域的X坐标 |
| e.clienY     | 返回鼠标相对于六拉起窗口可视区域的Y坐标 |
| e.pageX      | 返回鼠标相对于文档页面的X坐标           |
| e.pageY      | 返回鼠标相对于文档页面的Y坐标           |
| e.screenX    | 返回鼠标相对于电脑屏幕的X坐标           |
| e.screenY    | 返回鼠标相对于电脑屏幕的Y坐标           |

### 23.2、双击事件

| 事件      | 触发条件 |
| --------- | -------- |
| ondbclick | 双击触发 |

### 23.3、焦点事件

| 事件    | 触发条件 |
| ------- | -------- |
| onblur  | 失去焦点 |
| onfocus | 获得焦点 |

### 23.4、加载事件

| 事件   | 触发条件     |
| ------ | ------------ |
| onload | 加载完成触发 |

### 23.5、表单事件

| 事件     | 触发条件       |
| -------- | -------------- |
| onsubmit | 确认按钮被点击 |
| onreset  | 重置按钮被点击 |

| 事件     | 触发条件         |
| -------- | ---------------- |
| onscroll | 当发生滚动时触发 |

### 23.6、选择和改变事件

| 事件     | 触发条件         |
| -------- | ---------------- |
| onselect | 文本被选中       |
| onchange | 内容发送发生改变 |

### 23.7、滚动事件



## 24、常用的键盘事件

​	事件除了鼠标触发，还可以使用键盘触发

| 键盘事件   | 触发条件                             |
| ---------- | ------------------------------------ |
| onkeyup    | 某个键盘按键松开时触发               |
| onkeydown  | 某个键盘按键按下时触发               |
| onkeypress | 某个键盘按键按下时触发  不包含功能键 |

### 	24.1、键盘事件对象

| 键盘事件对象的属性 | 说明               |
| ------------------ | ------------------ |
| keyCode            | 返回改键的ASII码值 |

## 25、BOM概述

### 	25.1、什么是BOM

​	BOM(Browser Object Model)即浏览器对象模型，他提供了独立于内容而于浏览器窗口交互的的对象，其核心对象是window

​	BOM由一系列相关的对象构成，并且每个对象都提供了很多方法于属性

​	BOM缺乏标准，JavaScript语法的标准组织是ECMA,DOM的标准化组织是W3C,BOM最初是Netscape浏览器标准的一部分

| DOM                      | BOM                                 |
| ------------------------ | ----------------------------------- |
| 文档对象模型             | 浏览器对象模型                      |
| 把文档当作一个对象来看待 | 把浏览器当作一个对象来看待          |
| DOM的顶级对象是document  | BOM的顶级对象是window               |
| DOM主要是操作页面元素    | BOM是操作浏览器窗口交互的一些对象   |
| DOM是W3C标准规范         | BOM是浏览器厂商在各自浏览器上定义的 |

### 	25.2、BOM的构成

​	BOM比DOM更大，它包含DOM

![BOM的构成](E:\图片\笔记\BOM的构成.png)

​	**window对象是浏览器的顶级对象，它具有双重角色**

​	它是js访问浏览器窗口的一个接口

​	它是一个全局对象。定义在全局作用域中的变量或函数，都会变成window的属性和方法

## 26、window对象常见的事件

### 	26.1、窗体加载事件

```javascript
window.onload = function(){}
//或者
window.addEventListener('load',function(){})
```

​	window.onload是窗口(页面)加载事件，当文档内容完全加载完成会触发该事件(包括图像，脚本文件，CSS文件等)，就调用的处理函数

```javascript
document.addEventListener('DOMContentLoaded',function(){})
```

​	DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式、图像、flash等等

### 	26.2、调整窗体大小事件

```javascript
window.onresize = function(){}
//或者
window.addEventListener('resize',function(){})
```

​	window.onresize是跳转窗体大小加载事件，当触发时就调用的处理函数

## 27、定时器

### 	27.1、两种定时器

​	window对象给我们提供了2个--定时器

​	`setTimeout()`

​	`setInterval()`

### 	27.2、setTimeout()定时器

​	`window.setTimeout(调用函数,[延迟的毫秒数])`

​	window.setTimeout()方法用于设置一个定时器，该定时器在延迟事件到期后执行调用函数

### 9.4、location对象

| 方法名             | 返回值                                                       |
| ------------------ | ------------------------------------------------------------ |
| location.assign()  | 跟href一样，可以跳转页面(称为重新定向页面)                   |
| location.replace() | 替换当前页面，因为不记录历史，所有不能后退页面               |
| location.reload()  | 重新加载页面，相当于刷新按钮或者f5，如果参数为true强制刷新ctrl+f5 |
| location.search    | 获取参数                                                     |

### 9.5、navigator对象

​	navigator对象包含有关浏览器的信息，他有很多属性，我们最常用的userAgent,该属性可以返回由客户机发送服务器的user-agent的头部

### 9.6、history对象

​	window对象提供了一个history对象，与浏览器历史进行交互，该对象包含用户(在浏览器窗口中)访问过的URL地址

| history对象方法 | 作用                                                        |
| --------------- | ----------------------------------------------------------- |
| back()          | 后退功能                                                    |
| forward()       | 前进功能                                                    |
| go(参数)        | 前进后退功能 参数如果是1 前进1个界面 如果是-1 后退1一个界面 |

## 28、元素偏移量offset系列

### 	28.1、offset概述

​	offset翻译过来就是偏移量，我们使用offset系列相关属性可以动态得到该元素的位置(偏移) 大小等

​	获取元素距离带有定位父元素的位置

​	获取自身的高度和宽度

​	返回数值不带单位

| offset系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.offsetLeft   | 返回元素相对带有定位父元素左偏移                             |
| element.offsetTop    | 返回元素相对带有定位父元素上偏移                             |
| element.offsetWidth  | 返回自身包括padding 边框 内容区的宽度，返回数值不带单位      |
| element.offsetHeight | 返回自身包括padding 边框 内容去的高度 ，返回数值不带单位     |
| element.offsetParent | 返回该元素带有定位的父级元素 如果父级元素都没有定位则返回body |

### 	28.2、offset与style的区别

| offset                                        | style                                          |
| --------------------------------------------- | ---------------------------------------------- |
| offset可以得到任意样式表中的样式值            | style只能得到行内样式表中的值                  |
| offset系列获取的数值是没有单位的              | style.width获得的是带有单位的字符串            |
| offsetWidth包含padding +border+width          | style.width获得的是不包含的padding和border的值 |
| offsetWidth等属性是只读属性，只能读取不能赋值 | style.width是可读性属性，可以获取也可以赋值    |
| **所有 获取元素的位置大小，用offset更合适**   | **所有，要给元素更改值，需要用style更改**      |

## 29、元素可视区client系列

​	client翻译过来就是客户端，使用client系列的相关属性 来获取元素可视区的相关信息，通过clinet系列的相关属性可以动态的得到该元素 的边框大小、元素大小等。

| client系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.clientLeft   | 返回元素左边框的大小                                         |
| element.clientTop    | 返回元素上边框的大小                                         |
| element.clientWidth  | 返回自身包括padding  内容区的宽度 不含边框 返回数值不带单位  |
| element.clientHeight | 返回自身包括padding  内容去的高度  不含边框 返回数值不带单位 |

## 29、元素滚动scroll系列

​	scroll翻译过来就是滚动的，使用scroll系列的相关属性可以动态的得到该元素的大小，滚动距离等

| scroll系列属性       | 作用                                         |
| -------------------- | -------------------------------------------- |
| element.scrollTop    | 返回被卷去的顶部距离 返回数值不带参数        |
| element.scrollLeft   | 返回被卷去的左侧距离 返回数值不带参数        |
| elemen.scrollWidth   | 返回自身实际的宽度 不含宽度 返回数值不带单位 |
| element.scrollHeight | 返回自身实际的高度 不含边框 返回数值不带单位 |

### 	scroll事件

## 30、触屏事件

### 	30.1、触屏事件概述

​	移动端浏览器兼容性比较好，我们不需要考虑以前js的兼容性问题，可以放心的使用原生js书写效果，但是移动端也有自己独特的地方，比如触屏事件touch也称(触摸事件)，Android和ios都有

​	touch对象代表一个触摸点，触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可相应用户手指(或触屏笔)对屏幕或触控的操作

​	常见触屏事件

| 触屏touch事件 | 说明                          |
| ------------- | ----------------------------- |
| touchstart    | 手指触摸到一个DOM元素时触发   |
| touchmove     | 手指在一个DOM元素上滑动时触发 |
| touchend      | 手指从一个DOM元素上移开时触发 |

### 30.2、触摸事件对象(TouchEvent)

​	TouchEvent是一类描述手指在触摸平面(触摸屏、触摸板等)状态变化的事件。这类事件多用于描述一个或多个触电，使开发者可以检测触点的移动，触点的增加和减少，等等

​	touchstart、touchmove、touchend 三个事件都会有各自的事件对象

| 触摸列表       | 说明                                         |
| -------------- | -------------------------------------------- |
| touches        | 正在触摸屏幕的所有手指列表                   |
| targetTouches  | 正在触摸当前DOM元素上的手指列表              |
| changedTouches | 手指状态发生了改变，从无到有，从有到无的变化 |

## 31、JQuery 概述

### 	31.1、JavaScript库

​	JavaScript库：即library，是一个**封装**好的特定的**集合**(方法和函数)。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等

​	简单理解：就是一个JS文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能

​	比如JQuery，就是为了快速方便的操作DOM，里面基本都是函数(方法)

​	**常见的JavaScript库**

| jQuer         |
| ------------- |
| Prototype     |
| YUI           |
| Dojo          |
| Ext JS        |
| 移动端的zepto |

### 	31.2、jQery 的概念

​	jQuer是一个快速、简洁的JavaScript库，其设计宗旨是"write Less,Do More" ,即倡导写更少的代码，做更多的事情

​	j就是JavaScript；Query查询；意思就是查询js，把js中的DOM操作做了封装，我们可以快速查询使用里面的功能

​	**jQuery封装了JavaScript常用的功能代码**，优化了DOM操作、事件处理、动画设计和Ajax交互

​	学习jQuery本质：就是学习调用这些函数(方法)

​	jQuery出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率

### 	31.3、jQuery的优点

| 轻量级。核心文件才几十kb，不会影响页面加载速度               |
| ------------------------------------------------------------ |
| 跨浏览器兼容。基本兼容了现在主流的浏览器                     |
| 链式编程、隐式迭代                                           |
| 对事件、样式、动画支持，大大简化了DOM操作                    |
| 支持插件扩展开发。有着丰富的第三方的插件，例如树形菜单、日期控件、轮播图等 |
| 免费 开源                                                    |

## 32、jQuery的基本使用

### 	32.1、jQuery的下载

​	官方网址：https://jquery.com/

### 	32.2、jQuery的入口函数

```javascript
$(function(){
    ...//此处是页面DOM加载完成的入口
})
//或者
$(document).ready(function(){
    ...//此处是也买你DOM加载完成的入口
})
//等着DOM结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery帮我们完成了封装
//相当于原生js中的DOMContentLoaded
//不同于原生js中的load事件是等页面文档、外部的js文件、css文件、图片加载完毕才执行内部代码
```

### 	32.3、jQuery的顶级对象$

​	$是jQuery的别称，在代码中可以使用jQuery代替$,但一般为了方便，通常都直接使用$

​	$是jQuery的顶级对象，相当于原生JavaScript中的window。把元素利用$包装成jQuery对象，就可以调用jQuery的方法

### 	32.4、jQuery 对象和DOM 对象

​	利用原生js获取过来的对象就是DOM对象

​	jQuery方法获取的元素就是jQuery对象

​	jQuery对象的本质是：利用$对DOM对象包装后产生的对象(伪数组形式存储)

​	**DOM对象和jQuery对象是可以互相转换的**

​	因为原生js比jQuery更大，原生的一些属性和方法jQuery没有封装，要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用

​	**DOM对象转换为jQuery对象：$(DOM对象)**

```javascript
$('div')
```

​	**jQuery对象转换为DOM对象 两种方式**

```1
$('div')[index]  index是索引号

$('div').get(index)  index是索引号
```

## 33、jQuery的选择器

### 	33.1、jQuery基础选择器

​	原生js获取元素的方式很多，很杂，而且兼容性情况不一致，因此jQuery封装，使获取元素统一标准

```javascript
$('选择器')//里面选择器直接写css选择器即可，但是要加引号
```

| 名称       | 用法            | 描述                   |
| ---------- | --------------- | ---------------------- |
| ID选择器   | $('#id')        | 获取指定的ID的元素     |
| 全选择器   | $('*')          | 匹配所有的元素         |
| 类选择器   | $('.class')     | 获取指定的类的元素     |
| 标签选择器 | $('div')        | 获取同一标签的所有元素 |
| 并集选择器 | $('div,p,li')   | 选取多个元素           |
| 交集选择器 | $('li.current') | 交集元素               |

### 	33.2、jQuery层级选择器

| 名称       | 用法         | 描述                                                         |
| ---------- | ------------ | ------------------------------------------------------------ |
| 子代选择器 | `$("ul>li")` | 使用>号，获取最近一个子对象层级的元素；不会获取其他子对象层级的元素 |
| 后代选择器 | `$("ul li")` | 使用空格，代表后代选择器，获取ul下的所有的li元素，包括子对象层级下的子对象 |

### 	33.3、隐式迭代

​	遍历内部DOM元素(伪元素形式存储)的过程就叫做隐式迭代

​	简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们在进行循环，简化操作，方便调用

### 	33.4、jQuery筛选器

| 语法       | 用法          | 描述                                                       |
| ---------- | ------------- | ---------------------------------------------------------- |
| :first     | $('li:first') | 获取第一个li元素                                           |
| :last      | $('li:last')  | 获取最后一个li元素                                         |
| :eq(index) | $('li:eq(2)') | 获取到的li元素中，选择索引号为2的元素 ，index索引号从0开始 |
| :odd       | $('li:odd')   | 获取到的li元素中，选择索引号为奇数的元素                   |
| :even      | $('li:even')  | 获取到的li元素中，选择索引号为偶数的元素                   |

### 	33.5、jQuery筛选方法

| 语法                 | 用法                             | 说明                                                         |
| -------------------- | -------------------------------- | ------------------------------------------------------------ |
| `parent()`           | `$('li').parent()`               | 查找父级                                                     |
| `children(selector)` | `$('ui').children('li')`         | 相当于$("ul>li"),查找指定的最近一级的子元素                  |
| `find(selector)`     | `$('ui').find("li")`             | 相当于$("ul li"),后代选择器，查找ul中所有的li元素            |
| `siblings(selector)` | `$('.first').siblings('li')`     | 查找兄弟节点，不包括自身                                     |
| `nextAll([expr])`    | `$('.first').nextAll()`          | 查找当前元素之后的所有的同级元素                             |
| `prevtAll([expr])`   | `$('.first').prevtAll()`         | 查找当前元素之前的所有的同级元素                             |
| `hasClass(class)`    | `$('div').hasClass('protected')` | 检查当前元素是否含有每个特定的类，如果有返回true，没有返回false |
| `eq(index)`          | `$('li').qe(2)`                  | 相当于`$('li:eq(2)'),index从零开始                           |
| `parents(class)`     | `$('li').parents('class')`       | 在所有的父级元素中查找指定的那个父级元素                     |

### 33.6、链式编程

​	链式编程是为了节省代码量

```javascript
$(this).css('color','red').sibling().css('color','');
```

## 34、jQuery样式操作

### 34.1、操作css方法

​	jQuery可以使用css方法来修改简单的元素样式；也可以操作类，修改多个样式

​	参数只写属性名，不写值，则返回属性值

```javascript
$(this).css('color');
```

​	参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号

```javascript
$(this).css('color','red');
```

​	参数形式也可以是对象的形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不用加引号

```javascript
$(this).css({"color":"white","font-size":"20px"});
$(this).css({
    width:400,
    height:400,
    color:'red',
    fontSize:20
})
```

### 34.2、设置类样式方法

​	作用等同于classList，可以操作类样式，操作类里面的参数不需要加点

​	**添加类**

```javascript
$('div').addClass('current');
```

​	**删除类**

```javascript
$('div').removeClass('current');
```

​	**切换类     如果类存在就删除 不存在就添加**

```javascript
$('div').toggleClass('current');
```

### 34.3、类操作与className区别

​	原生JS中className会覆盖元素原先里面的类名

​	jQuery里面类操作只是对指定类进行操作，不影响原先的类型

## 35、jQuery效果

​	jQuery封装了很多动画效果，最为常见的如下：

| 显示隐藏 |     滑动      |   淡入淡出   | 自定义动画 |
| :------: | :-----------: | :----------: | :--------: |
|  show()  |  sildeDown()  |   fadeln()   | animate()  |
|  hide()  |   sildeUp()   |  fadeOut()   |            |
| toggle() | silDeToggle() | fadeToggle() |            |
|          |               |   fadeTo()   |            |

### 35.1、显示隐藏效果

​	**显示语法规范**

```javascript
show([speed],[easing],[fn])
```

​	**显示参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

​	**隐藏语法规范**

```javascript
hide([speed],[easing],[fn])
```

​	**隐藏参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

​	**切换语法规范**

```javascript
toggle([speed],[easing],[fn])
```

​	**切换参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

### 35.2、滑动效果

​	**下滑效果语法规范**

```javascript
slideDown([speed],[easing],[fn])
```

​	**下滑参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

​	**上滑效果语法规范**

```javascript
slideUp([speed],[easing],[fn])
```

​	**上滑参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

​	**滑动切换语法规范**

```javascript
slideToggle([speed],[easing],[fn])
```

​	**滑动切换参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

### 35.3、事件切换

```javascript
hover([over],out)
//over：鼠标移动到元素上要触发的函数，相当于mouseenter
//out：鼠标移出元素要触发的函数，相当于mouseleave
```

### 35.4、动画队列机器停止排队方法

​	**动画或效果队列**

​	动画或效果一旦触发就会执行，如果多次触发，就造成多个动画或效果排队执行

​	**停止排队**

```javascript
stop()
//stop()方法用于停止动画效果
//stop()写到动画的前面，相当于停止结束上一次的动画
```

### 35.5、淡入淡出效果

​	**淡入效果语法规范**

```javascript
fedeIn([speed],[easing],[fn])
```

​	**淡入参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

​	**淡出效果语法规范**

```javascript
fadeOut([speed],[easing],[fn])
```

​	**淡出参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

​	**淡入淡出切换效果语法规范**

```javascript
fadeToggle([speed],[easing],[fn])
```

​	**淡入淡出切换参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

​	**渐进方式调整到指定的不透明度**

```javascript
fadeTo([speed],opacity,[easing],[fn])
```

​	**淡入淡出切换参数**

​	参数可以全部省略，无动画直接显示

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	opacity:**透明度值必须填写，取值0~1之间 **	

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

### 35.6、自定义动画animate

```javascript
animate(params,[speed],[easing],[fn])
```

​	**参数**

​	params：**想要更改的样式属性，以对象形式传递，必须写。属性名可以不带引号，如果时复合属性则需要采取驼峰命名法borderLeft**，其他参数都可省略

​	speed：三种预定速度之一的字符串('slow','normal','fast')或表示动画时长的毫秒数值(如:1000);

​	easing:(Optional)用来指定切换效果，默认是"swing",可用参数"linear"

​	fn:回调函数，在动画执行完毕时执行的函数，每个元素执行一次

## 36、jQuery属性操作

### 36.1、设置或获取元素的固有属性prop()

​	所谓元素固有属性就是元素本身自带的属性，比如<a>元素里面的href，<input>元素里面的type

​	**获取属性值**

```javascript
prop(“属性”)
```

​	**设置属性值**

```
prop("属性","属性值")
```

### 36.2、设置或获取元素自定义属性值 attr()

​	**获取属性值**

```javascript
attr('属性')
```

​	**设置属性值**

```javascript
attr("属性"，"属性值")
```

### 36.3、数据缓存 data()

​	data()方法可以在指定元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都将被移除

​	**语法**

```javascript
data("属性","属性值")
```

## 37、jQuery文本属性值

​	主要针对元素的内容还有表单值的操作

### 37.1、普通元素内容html()  (相当于原生的innerHTML)

```javascript
html()			//获取元素内容
html("内容")	   //设置元素内容
```

### 37.2、普通元素文本内容text()  (相当于原生的innerText)

```javascript
text()			//获取元素文本内容
text("内容")	   //设置元素文本内容
```

### 37.3、表单的值val()  (相当于原生的value)

```javascript
val()			//获取值
val("内容")	   //设置值
```

### 37.4、toFixed() 保留小数

```javascript
(p*n).toFixed(2)
//toFixed()方法可以保留计算完成后的指定小数，后面的括号写的内容就是要保留的个数
```

## 38、jQuery元素操作

​	如何遍历、创建、添加、删除元素操作

### 38.1、遍历元素

​	jQuery隐私迭代是对同一类元素做了相同的操作，如果想给同类元素做不同的操作，就需要用到遍历

​	**语法一**

```javascript
$('div').each(function(index,domEle){xxx;})
//each()方法遍历匹配每一个元素。主要用于DOM处理
//function()里面的有两个参数，index是每个元素的索引号；domEle是每个DOM元素对象，不是jQuery对象
```

​	**语法二**

```javascript
$.each(object,function(index,element){xxx;})
//$.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象
//函数有两个参数：index是每个元素的索引号，element遍历内容
```

### 38.2、创建元素

​	**语法**

```javascript
$("<li></li>")
```

### 38.3、添加元素

​	**内部添加**

```javascript
element.append('内容')
//把内容放入匹配元素的最后面，类似于原生的appendChild
element.preoend('内容')
//把内容放入匹配元素的最前面
```

​	**外部添加**

```javascript
element.after('内容')
//把内容放入目标元素的后面
element.before('内容')
//把内容放入目标元素的前面
```

​	**内部添加，生成之后，是父子关系，外部添加，生成之后，是兄弟关系**

### 38.4、删除元素

```javascript
element.remove()
//删除匹配的元素本身
element.empty()
//删除匹配元素集合中的所有子元素
element.html("")
//清空匹配的元素内容
```

## 39、jQuery尺寸、位置操作

### 39.1、jQuery尺寸

| 语法                             | 用法                                               |
| :------------------------------- | :------------------------------------------------- |
| width() / height()               | 取得匹配元素宽度和高度值 只算width和height         |
| innerWidth() / innerHeight()     | 取得匹配元素宽度和高度值 包含padding               |
| outerWidth() / outerHright()     | 取得匹配元素宽度和高度值 包含padding、border       |
| outerWidth(true) / outerHeight() | 取得匹配元素宽度和高度值 包含padding border margin |

​	以上参数为空,则是获取相应的属性值，返回的是数字型

​	如果参数为数字，则是修改相应的值

​	参数可以i不但单位

### 39.2、jQuery位置

​	位置主要有三个offset(),position(),scrollTop()/scrollLeft()

​	**offset()设置或获取元素偏移**

```javascript
/*
*offset()方法设置或获取元素相当于文档的偏移坐标，跟父级没有关系
*该方法有两个属性left、top，offset().top用于获取元素距离文档顶部的距离，offset().left用于获取元素距离文档左侧的距离
*/
//语法
$(".son").offset();//获取
//设置值
$(".son").offset({
    top:300,
    left:400
})
```

​	**position()获取元素偏移**

```javascript
/*
*position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则返回距离文档的偏移距离
*position()方法不能设置元素的偏移量
*/
//语法
$(".son").position();//获取
```

​	**scrollTop() / scrollLeft() 被卷去的头部距离和被卷去的左侧距离**

```javascript
/*
*scrollTop()方法设置或返回被选元素被卷去的头部
*/
```

## 40、jQuery事件注册

​	**单个事件注册**

​		**语法**

```javascript
element.事件(function(){})
```

```
$('div').click(function(){事件处理程序})
```

### 40.1、事件处理on()绑定事件

​	on方法在匹配元素上绑定一个或多个事件的处理函数

​	**语法**

```javascript
element.on(events,[selector],fn)
//events:一个或多个用空格分隔的事件类型，如click，keydown等
//selector：元素的子选择器
//fn：回调函数，即绑定到元素身上的侦听函数
$("div").on({
    mouseover:function(){},
    mouseout:function(){},
    click:function(){}
})
//如果事件处理程序相同
$('div').on("mouseover mouseout",function(){
  	//事件处理程序  
})
```

​	事件委派操作，事件委派的定义就是把，原来子元素身上的事件绑定到父元素身上，就是把事件委派给父元素

```javascript
$('ul').on('click','li',function(){})
```

​	动态创建的元素，click()没有办法绑定事件,on()可以给动态生成的元素绑定事件

### 40.2、事件处理off()解绑事件

​	off()方法可以移除通过on()方法添加的事件处理程序

​	**语法**

```javascript
$('div').off(); //解除元素身上的所有事件
$("div").off('click');//解除了元素身上的指定事件
$("div").off("click",'li');//解除事件委托
```

有的事件只需要触发一次可以使用one()来绑定事件

### 40.3、自动触发事件   trigger()

​	有些事件我们希望自动触发，比如轮播图自动播放功能，可以利用定时器自动触发，不必操控触发

​	**语法**

```javascript
element.click()//第一种 简写形式
//元素.事件
element.trigger("type")//第二种 自动触发事件
//元素.trigger('事件')
//以上两种方式会触发元素的默认行为，第三种不会触发元素的默认行为
element.triggerHandler('type')//第三种 自动触发事件
//元素.triggerHandler("元素")
```

## 41、jQuery事件对象

​	事件被触发，就会有事件对象的产生

```javascript
element.on(events,[selector],function(event) {} )
```

​	**阻止默认行为**

```javascript
event.preventDefauit()或者retrun false
```

​	**阻止冒泡**

```javascript
event.stopPropagation()
```

## 42、jQuery对象拷贝

​	如果要把某个对象拷贝(合并)给另一个对象使用，此时可以使用$.extend()方法

​	**语法**

```javascript
$.extent([deep],target,object1,[objectN])
//deep:如果设置为true为深拷贝，默认为false浅拷贝
//target:要拷贝的目标对象
//object1:要拷贝到的对象
//会覆盖原有的数据
```

## 43、jQuery多库共存

  **问题：**

jQuery使用$作为标识符，随着jQuery的流行，其他js库也会用这$作为标识符，这样一起使用会引起冲突

 **需求：**

  需要一个解决方案，让jQuery和其他库的js库不存在冲突，可以同时存在，这就叫做多库共存

**jQuery解决方案：**

   1.把里面的$符号统一改为jQuery。比如jQuery("div")
   2.jQuery变量规定新的名词:$.noConflict()  var xx=$.noConflict();
**jQuery插件**
  jQuery功能比较有限，想要更复杂的效果，可以借助于jQuery插件完成
  这些插件也是依赖jQuery来完成的，所以必须要先引入jQuery文件
  jQuery插件常用的网站：
   jQuery插件库  http://www.jq22.com/
   jQuery之家   http://www.htmleaf.com/

