## 1、面向对象编程

### 	1.1、编程两大思想

​			面向过程

​			面向对象

### 	1.2、面向过程编程 POP(Process-oriented programming)

​			**面向过程**就是分析出解决问题需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。

​			**面向过程，就是按照我们分析好了的步骤，按步骤解决问题**	

### 	1.3、面向对象编程 OOP(Object Oriented Programming)

​			**面向对象**就是把事务分解为一个个对象，然后由对象之间分工合作。

​			**面向对象是以对象功能来划分问题，而不是步骤**

​			面向对象编程具有灵活，可复用性、容易维护和开发的优点

​			面向对象的特性：

​				**封装性**

​				**继承性**

​				**多态性**

### 	1.3、面向对象和面向过程的对比

​		**面向过程**

​			**优点：**性能比面向对象高，适合跟硬件联系很紧密的东西。

​			**缺点：**没有面向对象易维护、易复用、易拓展。

​		**面向对象**

​			**优点：**易维护、易复用、易拓展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合系统，使系统，更加灵活、更加易于维护

​			**缺点：**性能比面向过程低

## 2、ES6中的类和对象

​	**面向对象**

​		面向对象更贴近我们的实际生活，可以使用面向对象描述现实世界的事物，但是事物分为具体事物和抽象事物

​		面向对象的思维特点：

​			抽取(抽象)对象共用的属性和行为组织(封装)成一个类(模板)**

​			对类进行实例化，获取类的对象

###  2.1、对象

​	**在JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象**，例如字符串、数值、数组、函数等	

​	对象是由**属性**和**方法**组成

​		**属性：**事物的**特征**，在对象中用**属性**来表示(常用名词)

​		**方法：**事物的**行为**，在对象中用**方法**来表示(常用动词)

###  2.2、类 class

​	在 ES6 中新增了类的概念，可以使用 **class** 关键字声明一个类，之后以这个类来实例化对象

​	**类**抽象了对象的公共部分，它泛指某一大类(class)

​	**对象**特指某一个，通过实例化的一个具体的对象

###  2.3、创建类(create Class)

​	**语法：**

```js
class name{
    //class body
}
```

​	**创建实例**

```js
const xx = new Name()
```

​	**注意：类必须使用 new 实例化对象**

###  2.4、类 constructor 构造函数

​	**constructor()**方法是类的构造函数(默认方法)，**用于传递参数，返回实例对象**，通过new命令生成对象实例时，自动调用该方法。如果没有现实定义，类内部会自动给我们创建一个**constructor()**

### 2.5、类添加方法

​	**语法**

```js
class Person{
    constructor(uname,age){
        this.name = uname
        this.age = age
    }
    say(){
        console.log(this.name+'你好')
    }
}
```

### 2.6、三个注意点

​	1、在ES6中没有变量提升，所以必须先定义类，才能通过类实例化对象

​	2、类中的公共属性和方法必须加this使用

​	3、类里面的this指向问题

## 3、类的继承

### 3.1、继承

​	程序中的继承：子类可以继承父类的一些属性和方法 

​	**语法**

```js
class Father{
    //父类
}
class Son extends Father{
    //子类继承父类
}
```

### 3.2、super 关键字

​	**super关键字**用于访问和调用对象父类上的函数。**可以调用父类的构造函数，可以调用父类的普通函数**

​	**语法:父类的普通函数**

```js
class Father{
    say(){
        return '父类'
    }
}
class Son extends Father{ 
    say(){
        //super.say()  super调用父类的方法
        return super.say() + '的子类'
    }
}
const son = new Son()
console.log(son.say())
```

​	**语法：父类的构造函数**

```js
class Father{
    constructor(surname){
        this.name = surname
    }
}
class Son extends Father{
    constructor(surname,firstname){
        super(surname)			//调用父类的构造函数
        this.name = firstname	//定义子类公共属性
    }
}

const son = new Son()
son.
```

​	**子类在构造函数中使用super，必须放到this前面(必须先调用父类的构造函数，在使用子类的构造函数)**

## 4、构造函数和原型

### 4.1、概述

​	在典型的OOP的语言中如(java)，都存在类的概念，类就是对象模板，对象就是类的实例，但在ES6之前，JS中并没有引入类的概念

​	ES6，全程ECMAscript6.0，2015.06发版。但是目前浏览器的JavaScript时ES5版本，大多数高版本浏览器也支持ES6，不过只实现了ES6的部分特性和功能

​	在ES6之前，对象不是基于类创建的，而是用一种构造函数的特殊函数来定义对象和他们的特征

​	创建对象可以通过以下三种方式:

​		1、对象字面量

​		2、new Object()

​		3、自定义构造函数

### 4.2、构造函数

​	**构造函数**是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，他总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

​	在JS中，使用构造函数要注意两点：

​		1、构造函数用于创建某一类对象，其**首字符大写**

​		2、构造函数要**和new一起使用**才有意义

​	**new在指向时会做四件事情**

​		在内存中创建一个新的空对象

​		让this指向这个新的对象

​		指向构造函数里面的代码，给这个新对象添加属性和方法

​		返回这个对象(所有构造函数中不需要return)

​	JavaScript的构造函数中可以添加一些成语，可以在构造函数本身添加，也可以在构造函数内部的this上添加，通过这两种方式添加的成员，就分别成为静态成员和实例成员。

​	**静态成员：**在构造函数本身添加的成员成为**静态成员，只能由构造函数本身访问**

​	**实例成员：**在构造函数内部创建的对象成员成为**实例成员，只能由实例化的对象来访问**

### 4.3、构造函数的问题

​	构造函数方法很好用，但是**存在浪费内存的问题**

​	![image-20221130172239974](E:\图片\笔记\image-20221130172239974.png)

### 4.4、构造函数原型 prototype

​	构造函数通过原型分配的函数是所有对象**共享的**

​	JavaScript 规定，**每一个构造函数都有一个prototype属性**，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数拥有。

​	**我们可以把那些不变的方法，直接定义在prototype对象上，这样所有的对象都可以共享这些方法**

###  4.5、对象原型_proto__

​	**对象都会有一个属性_proto__**指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为对象有_proto__原型的存在

​	[_proto__对象原型和原型对象的prototype是等价的]()

### 4.6、constructor 构造函数

​	**对象原型(_proto__)**和**构造函数(prototype)原型对象**里面都有一个**constructor**属性，constructor我们称之为构造函数，因为它本身指回构造函数本身

​	constructor 主要用于记录该对象引用了哪个构造函数，他可以让原型对象重新指回原来的构造函数

### 4.7、构造函数、实例、原型对象三者之间的关系

​	![](E:\图片\笔记\image-20221201112423302.png)

### 4.8、原型链

![](E:\图片\笔记\image-20221201113001698.png)

### 4.9、JavaScript 的成员查找机制(规则)

​	当访问一个对象的属性(方法)时，首先查找这个**对象自身**有没有该属性

​	如果没有就查找他的原型(也就是_proto__指向的**prototype原型对象**)

​	如果还没有就查找原型对象的原型(**Object的原型对象**)

​	以此类推一直找到Object原型对象的原型**Null**为止

### 4.10、原型对象this 指向问题

​	在构造函数中，里面的this指向的是对象实例

​	原型对象里面的this指向的是实例对象 ldh

### 4.11、拓展内置对象

​	可以通过原型对象，对原来的内置对象进行拓展自定义的方法。比如给数组增加自定义求和的功能

​	**注意：数组和字符串内置对象不能给原型对象覆盖操作Array.prototype={}，只能是Array.prototype.xxx = function (){}的方式**

## 5、继承

​	ES6之前并没有提供extends 继承。我们可以通过**构造函数+原型对象**模拟实现继承，被称为组合继承

### 5.1、call()

​	调用这个函数，并且修改函数运行时的this指向

```js
fun.call(thisArg,arg1,agr2,...)
```

​	**thisArg:**当前调用函数this指向的对象

​	**arg1，arg2：**传递其他参数

### 5.2、借用构造函数继承父类属性

​	核心原理：通过call() 吧父类型的this指向子类型的this，这样就可以实现子类型继承父类型的属性

```js
<script>
        // 借用构造函数继承父类属性
        // 父类构造函数
        function Father(uname,age){
            this.name = uname
            this.age = age
        }
        // 子类构造函数
        function Son(uname,age){
            Father.call(this,uname,age)
        }

        const son = new Son('ldh',45)
        console.log(son)

    </script>
```

### 5.3、借用原型对象继承父类型方法

```js
 <script>
        // 借用构造函数继承父类属性
        // 父类构造函数
        function Father(uname,age){
            this.name = uname
            this.age = age
        }

        Father.prototype.money = function(){
            console.log(11111111)
        }

        // 子类构造函数
        function Son(uname,age){
            Father.call(this,uname,age)
        }

        // Son.prototype = Father.prototype 这样直接赋值会有问题，如果修改了子原型对象，父原型对象也会跟着一起变化
        Son.prototype = new Father()
        //如果利用对象的形式修改了原型对象，别忘了利用constructor 指回原来的构造函数
        Son.prototype.constructor = Son

        Son.prototype.exam =  function (){
            console.log('考试')
        }

        const son = new Son('ldh',45)
        console.log(son)
        console.log(Father.prototype)
        console.log(Son.prototype.constructor)

    </script>
```

![image-20221203135548497](E:\图片\笔记\image-20221203135548497.png)

## 6、类的本质

​	class 的本质还是 function

​	类的所以方法都定义在prototype属性上

​	类创建的实例，里面也有_proto__指向类的prototype原型对象

​	所以ES6的类他的绝大部分功能，ES5也能做到，新的class写法只是让对象原型的写法更加清晰、更加面向对象编程的语法而已

​	所以ES6的类其实就是语法糖

​	语法糖：语法糖就是一种便携写法。简单理解，有两种方法可以实现同样的功能，但是一种写法更加清晰、方便、那么这个方法就是语法糖

## 7、ES5中新增的方法

### 7.1、ES5新增方法概述

ES5中给我们新增了一些方法，可以很方便的操作数组或者字符串，这些方法主要包括:

​	数组方法

​	字符串方法

​	对象方法

### 7.2、数组方法

​	迭代(遍历)方法:forEach()、map()、fiter()、some()、every()

```js
/*array.forEach(function(currentValue,index,arr))
*currentValue:数组当前的索引值
*index：数组当前项的索引
*arr：数组对象本身
*/
const arr = [1,2,3]
arr.forEach(function(value,index,array){
	console.log('每个数组元素'+value)
	console.log('每个数组元素的索引号'+index)
	console.log('数组本身'+array)
}) 
```

```js
/*array.fiter(function(currentValue,index,arr))
* fiter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所以元素，**主要用于筛选数组**
* 注意：它返回的是一个新数组
*currentValue:数组当前的索引值
*index：数组当前项的索引
*arr：数组对象本身
*/
const  arr = [12,66,4,88]
const newArr = arr.filter(function(value,index,array){
	return value >= 20
	})
console.log(newArr)
```

```js
/*array.some(function(currentValue,index,arr))
* some()方法用来检测数组中的元素是否满足指定条件，就查找数组中是否有满足条件的元素
* 注意：它返回的是一个布尔值，如果查找到这个元素，就返回true，如果找不到就返回false
* 如果找到第一个满足条件的元素，则终止循环，不在继续查找
*currentValue:数组当前的索引值
*index：数组当前项的索引
*arr：数组对象本身
*/
const arr = [10,20,4]
const flag = arr.some(function(value,index,array){
	return value >= 20
})
console.log(flag)
```

### 7.3、字符串方法

​	trim()方法会从一个字符串的两端删除空白字符

```js
str.trim()
```

​	trim()方法并不会影响原字符串本身，它返回的是一个新的字符串

### 7.4、对象方法

​	Object.keys()用于获取对象自身所以的属性

```js
object.keys(obj)
/*
* 效果类似 for...in
* 返回一个由属性名组成的数组
*/
```

​	Object.defineProperty()定义对象中的新属性或修改原有属性

```js
object.defineProperty(obj,prop,descriptor)
/*
* obj:必须。目标对象
* prop：必须。需要定义或修改的属性的名字
* descriptor:必须。目标属性所拥有的特性
*/
// Object.defineProperty()第三个参数说明:以对象形式{}书写
/*
* value：设置属性的值，默认为undefined
* writable：值是否可以重写。true|false 默认false
* enumerable：目标属性是否可以被枚举。true|false 默认false
* configurable：目标属性是否可以被删除或是否可以再次修改特性true|false 默认false
*/
```

## 8、函数的定义和调用

### 8.1、函数的声明方式

​	函数声明方式function关键字(命名函数)

​	函数表达式（匿名函数）

​	new Function()

```js
const fun = new Function('参数1','参数2',...,'函数体')
/*
* Function里面参数都必须是字符串格式
* 第三种方式执行效率低，也不方便书写，因此较少使用
* 所有函数都是Function的实例(对象)
* 函数也属性对象
*/
```

### 8.2、函数的调用方式

​	普通函数

​	对象的方法

​	构造函数

​	绑定事件函数

​	定时器函数

​	立即执行函数

## 9、this

### 2.1、函数内 this 的指向

​	这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this的指向不同，一般指向我们的调用者：

| 调用方式     | this指向                                   |
| ------------ | ------------------------------------------ |
| 普通函数调用 | window                                     |
| 构造函数调用 | 实例对象，原型对象里面的方法也指向实例对象 |
| 对象方法调用 | 该方法所属对象                             |
| 事件绑定方法 | 绑定事件对象                               |
| 定时器函数   | window                                     |
| 立即执行函数 | window                                     |

### 2.2、改变函数内部的this指向

​	JavaScript 为我们专门提供了一些函数方法来帮助我们更优雅的处理函数内部 this 的指向问题，常用的有bind()、call()、apply()三种方法

​	**call()方法**

​	call() 方法**调用**一个对象。简单理解为调用函数的方式，但是它可以改变this的指向

```js
fun.call(thisArg,arg1,arg2,...)
```

​	**apply()方法**

​	apply()方法**调用**一个函数。简单理解为调用函数的方式，但是它可以改变this的指向

```js
fun.apply(thisArg,[argsArray])
/*
* thisArg:在fun函数运行时指定的this值
* argsArray：传递的值，必须包含在*数组*里面
* 返回值就是函数的返回值，因为它就是调用函数
*/
```

​	**bind()方法**

​	bind()方法不会调用函数。但是能改变函数内部的this指向

```js
fun.bind(thisArg,arg1,arg2,...)
/*
* thisArg:在fun函数运行时指定的 this 值
* arg1,arg2:传递的其他参数
* 返回由指定的this值和初始化参数改造的*原函数拷贝*
*/
```

​	**call()、apply()、bind() 总结**

​	**相同点**

​		都可以改变函数内部的this指向

​	**区别点**

​		call 和 apply 会调用函数，并且改变函数内部this的指向

​		call 和 apply 传递的参数不一样，call 传递参数arg1，arg2..形式，apply必须以数组形式[arg1,arg2]

​		bind 不会调用函数，可以改变函数内部this指向

​	**主要应用场景**

​		call 经常做继承

​		apply 经常跟数组有关系，比如借助数学对象实现数组最大值和最小值

​		bind 不调用函数，但是还想改变this指向，比如定时器内部的this指向

## 10、严格模式

### 10.1、什么时严格模式

​	JavaScript 除了提供正常模式外，还提供了**严格模式（strict mode）**。ES5的严格模式是采用具有限制性JavaScript变体的一种方式，即在严格的条件下运行JS代码

​	严格模式在IE10以上的版本浏览器中才会被支持，就版本浏览器中会被忽略

​	严格模式对正常的JavaScript语义做了一些更改：

​		消除了JavaScript 语法的一些不合理、不严谨之处、减少了一些怪异行为

​		消除了代码运行的一些不安全之处，保证代码运行的安全

​		提高了编译器效率，怎加运行速度

​		禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来版本的JavaScript做好铺垫。比如一些保留字如:class enum,export,extends,import,super不能做变量名

### 10.2、开启严格模式

​	严格模式可以应用到**整个脚本**或**个别函数**中。因此在使用时，我们可以将严格模式分为**为脚本开启严格模式**和**为函数开启严格模式**两种情况

​	**为脚本开启严格模式**

​	为整个脚本文件开启严格模式，需要**在所以语句之前放一个特定语句（use strict）**

```js
<script>
	'use scrict'
</script>
//或
<script>
	(()=>{
		'use scrict'
	})
</script>
```

​	**为函数开启严格模式**要给某个函数开启严格模式，需要把**use scrict 声明放在所以函数体语句之前

```js
 <script>
	function fn(){
		'use scrict' 
 	}
	function fun(){}
</script>
```

### 10.4、严格模式中的变化

​	严格模式对 JavaScript 的语法和行为，都做了一些改变

​	**变量规定**

​		在正常模式中，如果一个变量没有声明就赋值，默认时全局变量。严格模式禁止这种用法，变量必须先声明，然后再使用

​		严禁删除已经声明的变量。例如，delete x 语法是错误的

​	**严格模式下this指向的问题**

​		以前在全局作用域函数中的this指向window对象

​		**严格模式下全局作用域函数中的this是undefined**

​		以前构造函数不加new也可调用，但普通函数，this指向全局对象

​		**严格模式下，如果构造函数不加new调用，this会报错**

​		new实例化的构造函数指向创建的对象实例

​		定时器this还是指向window

​		事件、对象还是指向调用者

​	**函数变化**

​		函数不能有重名的**参数**

​		函数必须声明在顶层.新版本的JavaScript会引入块级作用域。为了与新版本接轨，不允许在非函数的代码块中声明函数		

## 11、高阶函数

​	**高阶函数**是对其他函数进行操作的函数，它**接收函数作为参数或将函数作为返回值输出**

```js
function fn(callback){
    callback&&callback()
}
fn(function(){
    alert('hi')
})

function fn(){
    return function(){}
}
fn()
```

​	此时fn就是一个高阶函数

​	函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是回调函数

## 12、闭包

### 12.1、变量作用域

​	变量根据作用域的不同分为两种：全局作用域和局部变量

### 12.2、什么是闭包

​	**闭包(closure)**指有**权访**问另一个函数作用域中的变量的**函数**	--JavaScript 高级程序设计

​	简单理解就是，一个作用域可以访问另一个函数内部的局部变量

### 12.3、闭包的作用

​	延伸了变量的作用范围

### 12.4、闭包案例

​	循环注册点击事件

## 13、递归

### 13.1、什么是递归

​	如果**一个函数在内部可以调用其本身**，那么这个函数就是**递归函数**

​	简单理解：函数内部自己调用自己，这个函数就是递归函数

​	递归函数的作用和循环效果一样

​	由于递归很容易发生 ‘’栈溢出‘’ 错误(stack overflow) ，所以**必须要加退出条件return**

### 13.2、浅拷贝和深拷贝

​	浅拷贝只是拷贝一层，更深层次对象级别的只拷贝引用

​	深拷贝拷贝多层，每一级别的数据都会拷贝

​	Object.assign(target,...sources) es6新增方法可以浅拷贝

## 14、正则表达式概述

### 14.1、什么是正则表达式

​	**正则表达式(Regular Expression)** 是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象

​	正则表通常被用来检索、替换那些符合某个模式(规则)的文本，例如验证表单：用户名表单只能输入英文字母，数字或下划线，昵称输入框中可以输入中文(**匹配**)。此外，正则表达式还常用于过滤页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分（提取）等

​	其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript正则表达式完成表单验证

### 14.2、正则表达式的特点

​	灵活性、逻辑性和功能性非常的强

​	可以迅速地用极简单的方式达到字符串的复杂控制

​	对于刚接触的人来说，比较晦涩难懂。比如:\w+([-+.]\w+)*@\w+([-.]\w+)**\\.\w+([-.]\w)+*$

​	实际开发，一般都是直接复制写好的正则表达式，但是要求会使用正则表达式并根据实际情况修改正则表达式.比如用户名:/[a-z0-0_-]{3，16}$/

## 15、正则表达式在JavaScript中的使用

### 15.1、创建正则表达式

​	在JavaScript中，可以通过两种方式创建一个正则表达式

​	**通过调用 RegExp 对象的构造函数创建**

```js
const 变量名 = new RegExp(/表达式/)
```

​	**通过字面量来创建**

```js
const 变量名 = /表达式/
```

### 15.2、测试正则表达式 test

​	test()正则对象方法、用于检查字符串是否符合该范围，该对象会返回true或false，其参数是测试字符串

```js
regexpObj.test(str)
/*
* regexpObj:是写的正则表达式
* str：要检测的文本
*/
```

## 16、正则表达式中的特殊字符

### 16.1、正则表达式的组成

​	一个正则表达式可以由**简单的字符构成**，比如/abc/，**也可以是简单和特殊字符的组合**，比如/ab*c/。其中特殊字符也被称为**元字符**，在正则表达式中是具有**特殊**意义的专业**符合**如$、+等。

### 16.2、边界符

​	正则表达式中的边界符（位置符）用来提示**字符所处的位置**，主要有两个字符

| 边界符 | 说明                          |
| ------ | ----------------------------- |
| ^      | 表示匹配 行首的文本(以谁开始) |
| $      | 表示匹配 行尾的文本(以谁结束) |

​	**如国 ^和$在一起，表示为精确匹配**

### 16.3、字符类

​	字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。**所有可供选择的字符都放在方括号内**。

​	[-] 方框号内部 范围符-

### 16.4、量词符

​	量词符用来**设定某个模式出现的次数**

| 量词  | 说明             |
| ----- | ---------------- |
| *     | 重复零次或更多次 |
| +     | 重复一次或更多次 |
| ？    | 重复零次或一次   |
| {n}   | 重复n次          |
| {n,}  | 重复n次或更多次  |
| {n,m} | 重复n到m次       |

### 16.5、括号总结

​	大括号	量词符	里面表示重复的次数

​	中括号	字符集合	匹配方括号中的任意字符

​	小括号 表示优先级

### 16.6、预定义类

​	预定义类指的是**某些常见模式的简写模式**

| 预定类 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| \d     | 匹配0-9之间的任一数字，相当于[0-9]                           |
| \D     | 匹配所以0-9以外的字符，相当于[^0-9\]                         |
| \w     | 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]             |
| \W     | 除所以字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_\]     |
| \s     | 匹配空格（包括换行符、制表符 、空格等等），相当于[\t\r\n\v\f\] |
| \S     | 匹配非空格的字符，相当于[^\t\r\n\v\f\]                       |

## 17、正则表达式中的替换

### 17.1、replace 替换

​	replace()方法可以实现替换字符串的操作，用来替换的参数可以是一个字符串或者是一个正则表达式

```js
stringObject.replace(regexp/substr,replacement)
/*
* 参数一：被替换的字符串 或者 正则表达式
* 参数二：替换为的字符串
* 返回值：一个新的字符串
*/
```

### 17.3、正则表达式参数

```js
/表达式/[switch]
```

​	switch(也称修饰符)按照什么样的模式来匹配。有三种值：

​		g：全局匹配

​		i：忽略大小写

​		gi：全局匹配+忽略大小写

## 18、ES6

### 18.1、什么是ES6

​	ES的全程是ECMAScript，它是由ECMA国际标准化组织，制定的**一项脚本语言的标准化规范**

![image-20221211141949460](E:\图片\笔记\image-20221211141949460.png)

​	ES6实际上是一个泛指，泛指 ES 2015 及后续版本

### 18.2、为什么使用ES6

​	每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript 语言本身也有一些令人不满意的地方

​		变量提升特性增加了程序运行时的不可预测性

​		语法过于松散，实现相同功能，不同的人会写出不同的代码

### 18.3、let

​	ES6新增的用于声明的关键字

​		let声明的变量只在所处的块级有效

```js
if (true){
    let a = 10
}
console.log(a) // a is not defined
在一个大括号中 使用 let 关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的
```

​		不存在变量提升

```js
console.log(a) // a is not defined
let a = 100
```

​		暂时性死区

```js
var tmp = 123
if(true){
    tmp = 'abc'
    let tmp
}
```

### 18.4、const

​	作用：声明常量，常量就是值(内存地址)不能变化的量

​		具有块级作用域

```js
if(true){
	const s = 10
}
console.log(s) // a is not defined
```

​	声明常量必须赋值

```js
const PI	// Missing initializer in const declaration
```

​	常量赋值后，值不能修改

```js
const PI = 3.14
PI = 100	// Assignment to constant variable
```

```js
const ary = [100,200]
ary[0]	=	'a'
ary[1]	=	'b'
console.log(ary)  //['a','b']
ary = ['a','b']	  // Assignment to constant variable
```

### 18.5、let、const、var 的区别

​	使用**var**声明的变量，其作用域为**该语句所在的函数内，且存在变量提升现象**

​	使用**let**声明的变量，其作用域为**该语句所在的代码块中，不能存在变量提升现象**

​	使用**const**声明的是常量，在后面出现的代码中**不能在修改该常量的值**

| var          | let            | const          |
| ------------ | -------------- | -------------- |
| 函数作用域   | 块级作用域     | 块级作用域     |
| 存在变量提升 | 不存在变量提升 | 不存在变量提升 |
| 值可更改     | 值可更改       | 值不可更改     |

 
